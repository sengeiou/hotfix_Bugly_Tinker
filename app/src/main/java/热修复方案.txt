
一、Tinker
接入
http://blog.csdn.net/y97524027/article/details/52678428
官方接入指南
https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97

Bugly Tinker
https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/

热更新能力是Bugly为解决开发者紧急修复线上bug，而无需重新发版让用户无感知就能把问题修复的一项能力。
Bugly目前采用微信Tinker的开源方案，开发者只需要集成提供的SDK就可以实现自动下载补丁包、合成、并应用补丁的功能，
也提供了热更新管理后台让开发者对每个版本补丁进行管理。
为什么使用Bugly热更新？
	无需关注Tinker是如何合成补丁的
	无需自己搭建补丁管理后台
	无需考虑后台下发补丁策略的任何事情
	无需考虑补丁下载合成的时机，处理后台下发的策略
	我们提供了更加方便集成Tinker的方式
	我们通过HTTPS及签名校验等机制保障补丁下发的安全性
	丰富的下发维度控制，有效控制补丁影响范围
	我们提供了应用升级一站式解决方案

二、热修复基础
参考：一步步手动实现热修复



---------------------------------插件化
将一些独立的功能做成一个单独的apk，当打开的时候使用DexClassLoader动态加载，然后使用反射机制来调用插件中的类和方法。
但这种方案存在着以下两个问题：
1. 插件化只适合一些比较独立的模块；
2. 必须通过反射机制去调用插件的类和方法，因此，必须搭配一套插件框架来配合使用；

访问插件包中的资源
//1、引入插件的AssetManager
String apkPath="";
AssetManager assetManager = AssetManager.class.newInstance();
AssetManager.class.getDeclaredMethod("addAssetPath", String.class).invoke(
        assetManager, apkPath);
//2、获得插件的Resource
new Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());
//3、通过资源名字/类型/插件包名获取资源
使用resources.getIdentifier(资源名称，资源类型，资源所在的包名)
String str = resources.getString(resources.getIdentifier("app_name", "string", "h3c.plugina"));
Drawable drawable=resources.getDrawable(resources.getIdentifier("ic_launcher", "mipmap", "h3c.plugina"))


----------------------------------dex分包
http://blog.csdn.net/vurtne_ye/article/details/39666381
其原理是将编译好的class文件拆分打包成2个dex，绕过dex方法数量的限制以及安装时的检查，在运行时再动态加载第二个dex文件中。
优点：
1、绕过 一个dex文件最多只支持65536个方法 。(目前android已提供支持android-support-multidex)
2、减少apk体积，可动态加载dex

第一步：dex分包
第二步：运行时动态加载第二个dex文件。


------------------------------------Android分包MultiDex原理详解
一、使用
1、在build.gradle中添加配置
android {
    compileSdkVersion 21
    buildToolsVersion "21.1.0"

    defaultConfig {
        ...
        minSdkVersion 14
        targetSdkVersion 21
        ...

        // 开启multiDex支持
        multiDexEnabled true
    }
    ...
}

dependencies {
  //引用multidex
  compile 'com.android.support:multidex:1.0.1'
}

2、继承MutiDexApplication或者覆写Application中的attachBaseContext()方法.
public class MyApplication extends MutiDexApplication
           或
public class MyApplication extends Application{
   public  void onCreate(){
       //初始化
   }
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
注意：attachBaseContext比onCreate()方法先执行，因此可在attachBaseContext方法中合成dex，因为我们一般都在onCreate中完成初始化，
会引用其他类，所以必须在加载其他类之前完成dex合并

http://blog.csdn.net/t12x3456/article/details/40837287
http://www.mamicode.com/info-detail-1031299.html


------------------------------------Android Instant Run


































