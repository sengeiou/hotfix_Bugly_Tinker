------动态加载系列文章
https://zhuanlan.zhihu.com/kaede
http://blog.csdn.net/googdev/article/details/53067400

一、Tinker
接入
http://blog.csdn.net/y97524027/article/details/52678428
官方接入指南
https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97

Bugly Tinker
https://bugly.qq.com/docs/user-guide/instruction-manual-android-hotfix/

热更新能力是Bugly为解决开发者紧急修复线上bug，而无需重新发版让用户无感知就能把问题修复的一项能力。
Bugly目前采用微信Tinker的开源方案，开发者只需要集成提供的SDK就可以实现自动下载补丁包、合成、并应用补丁的功能，
也提供了热更新管理后台让开发者对每个版本补丁进行管理。
为什么使用Bugly热更新？
	无需关注Tinker是如何合成补丁的
	无需自己搭建补丁管理后台
	无需考虑后台下发补丁策略的任何事情
	无需考虑补丁下载合成的时机，处理后台下发的策略
	我们提供了更加方便集成Tinker的方式
	我们通过HTTPS及签名校验等机制保障补丁下发的安全性
	丰富的下发维度控制，有效控制补丁影响范围
	我们提供了应用升级一站式解决方案

解决问题：
1、Application动态替换
2、两个相关联的类在不同的dex中
参考：https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a

ModuleManager引用了QzoneActivityManager，这这两个类所在的dex不在一起，其中：
1. ModuleManager在classes.dex中
2. QzoneActivityManager在patch.dex中
结果发生了错误。
这里有个问题,拆分dex的很多类都不是在同一个dex内的,怎么没有问题?

从代码上来看，如果两个相关联的类在不同的dex中就会报错，但是拆分dex没有报错这是为什么，原来这个校验的前提是：
if(!fromUnverifiedConstant&&IS_CLASS_FLAG_SET(referrer,CLASS_ISPREVERIFIED)){

}
如果引用者（也就是ModuleManager）这个类被打上了CLASS_ISPREVERIFIED标志，那么就会进行dex的校验。
那么这个标志是什么时候被打上去的？在DexPrepare.cpp找到了一下代码：
if(doVerify){
     if(dvmVerifyClass(clazz)){
           ((DexClassDef*) pClassDef)->accessFlags|=CLASS_ISPREVERIFIED;
           verified=true;
     }
}
这段代码是dex转化成odex(dexopt)的代码中的一段，我们知道当一个apk在安装的时候，apk中的classes.dex会被虚拟机(dexopt)优化成odex文件，然后才会拿去执行。
虚拟机在启动的时候，会有许多的启动参数，其中一项就是verify选项，当verify选项被打开的时候，上面doVerify变量为true，那么就会执行dvmVerifyClass进行类的校验，
如果dvmVerifyClass校验类成功，那么这个类会被打上CLASS_ISPREVERIFIED的标志,那么具体的校验过程是什么样子的呢？ 此代码在DexVerify.cpp中，如下
1. 验证clazz->directMethods方法，directMethods包含了以下方法：
    1). static方法
    2). private方法
    3). 构造函数
2. clazz->virtualMethods
    1). 虚函数=override方法?
概括一下就是如果以上方法中直接引用到的类和class文件都在同一个dex中的话，那么这个类就会被打上CLASS_ISPREVERIFIED：
classes.dex中
public classA{
  public A(){
      System.out.println(AntilazyLoad.class);//如果A与AntilazyLoad在一个dex中的话，那么A这个类就会被打上CLASS_ISPREVERIFIED
   }
}
public class AntilazyLoad{

}
所以为了实现补丁方案，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。
最终QQ空间的方案是往所有类的构造函数里面插入了一段代码，代码如下：
if (ClassVerifier.PREVENT_VERIFY) {
   System.out.println(AntilazyLoad.class);
}
其中AntilazyLoad类会被打包成单独的hack.dex，这样当安装apk的时候，classes.dex内的类都会引用一个在不相同dex中的AntilazyLoad类，
这样就防止了类被打上CLASS_ISPREVERIFIED的标志了，只要没被打上这个标志的类都可以进行打补丁操作。
之所以选择构造函数是因为他不增加方法数，一个类即使没有显式的构造函数，也会有一个隐式的默认构造函数。
空间使用的是在字节码插入代码,而不是源代码插入，使用的是javaassist库来进行字节码插入的。

3、如何打包补丁包？
1）. 空间在正式版本发布的时候，会生成一份缓存文件，里面记录了所有class文件的md5，还有一份mapping混淆文件。
2）. 在后续的版本中使用-applymapping选项，应用正式版本的mapping文件，然后计算编译完成后的class文件的md5和正式版本进行比较，把不相同的class文件打包成补丁包。
备注:该方案现在也应用到我们的编译过程当中,编译不需要重新打包dex,只需要把修改过的类的class文件打包成patch dex,然后放到sdcard下,那么就会让改变的代码生效。


二、热修复基础
参考：一步步手动实现热修复

---------------------------------插件化
将一些独立的功能做成一个单独的apk，当打开的时候使用DexClassLoader动态加载，然后使用反射机制来调用插件中的类和方法。
但这种方案存在着以下两个问题：
1. 插件化只适合一些比较独立的模块；
2. 必须通过反射机制去调用插件的类和方法，因此，必须搭配一套插件框架来配合使用；

访问插件包中的资源
//1、引入插件的AssetManager
String apkPath="";
AssetManager assetManager = AssetManager.class.newInstance();
AssetManager.class.getDeclaredMethod("addAssetPath", String.class).invoke(
        assetManager, apkPath);
//2、获得插件的Resource
new Resources(assetManager, context.getResources().getDisplayMetrics(), context.getResources().getConfiguration());
//3、通过资源名字/类型/插件包名获取资源
使用resources.getIdentifier(资源名称，资源类型，资源所在的包名)
String str = resources.getString(resources.getIdentifier("app_name", "string", "h3c.plugina"));
Drawable drawable=resources.getDrawable(resources.getIdentifier("ic_launcher", "mipmap", "h3c.plugina"))


----------------------------------dex分包
http://blog.csdn.net/vurtne_ye/article/details/39666381
其原理是将编译好的class文件拆分打包成2个dex，绕过dex方法数量的限制以及安装时的检查，在运行时再动态加载第二个dex文件中。
优点：
1、绕过 一个dex文件最多只支持65536个方法 。(目前android已提供支持android-support-multidex)
2、减少apk体积，可动态加载dex

第一步：dex分包
第二步：运行时动态加载第二个dex文件。


------------------------------------Android分包MultiDex原理详解
一、使用
1、在build.gradle中添加配置
android {
    compileSdkVersion 21
    buildToolsVersion "21.1.0"

    defaultConfig {
        ...
        minSdkVersion 14
        targetSdkVersion 21
        ...

        // 开启multiDex支持
        multiDexEnabled true
    }
    ...
}

dependencies {
  //引用multidex
  compile 'com.android.support:multidex:1.0.1'
}

2、继承MutiDexApplication或者覆写Application中的attachBaseContext()方法.
public class MyApplication extends MutiDexApplication
           或
public class MyApplication extends Application{
   public  void onCreate(){
       //初始化
   }
    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
注意：attachBaseContext比onCreate()方法先执行，因此可在attachBaseContext方法中合成dex，因为我们一般都在onCreate中完成初始化，
会引用其他类，所以必须在加载其他类之前完成dex合并

http://blog.csdn.net/t12x3456/article/details/40837287
http://www.mamicode.com/info-detail-1031299.html


------------------------------------Android Instant Run


































